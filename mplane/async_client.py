#
# vim: tabstop=4 expandtab shiftwidth=4 softtabstop=4
##
# mPlane Protocol Reference Implementation
# Client SDK API implementation
#
# (c) 2013-2015 mPlane Consortium (http://www.ict-mplane.eu)
#               Author: Brian Trammell <brian@trammell.ch>
#
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU Lesser General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option) any
# later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License along with
# this program.  If not, see <http://www.gnu.org/licenses/>.
#

import asyncio
import logging
import websockets
import collections

import mplane.model
import mplane.azn
import mplane.tls

logger = logging.getLogger(__name__)


# NOTE: Link section rewriting should happen on the client side.

class ClientComponentContext:
    """
    Represents all the state a Client must keep 
    for a given Component: available Capabilities, pending Receipts,
    cached Results, and information for re-establishing a connection
    to the component (for WSClientClient).

    """
    def __init__(self, coid, url=None):
        # stash url and component identity
        self.url = url
        self.coid = coid

        # capabilities, receipts, and results
        self.capabilities = {}
        self.receipts = {}
        self.results = {}

        # FIXME handle partial results

        # label to token map
        self.token_for_label = {}

        # Outgoing message queue
        self.outq = asyncio.Queue()

        logger.debug("created "+repr(self))

    def send(self, msg):
        self.outq.put_nowait(msg)

    def __repr__(self):
        return "ClientComponentContext(%s, %s)" % (repr(self.coid), repr(self.url))

class CommonClient:
    """
    Core implementation of a generic asynchronous programmatic client. 
    Keeps track of available capabilities, pending receipts, and
    recent results from a set of components, and allows the 

    Used for common component state management for WSClientClient and 
    WSServerClient.

    """

    def __init__(self, config):
        self._ccc = {}
        self.config = config

        self._token_invoked = {}
        self._token_complete = {}
        self._i_have_capabilities = asyncio.Event()

        # serial number to use for autogenerated labels
        self.next_label_serial = 1

    def _component_context(self, coid, url=None):
        if coid not in self._ccc:
            self._ccc[coid] = ClientComponentContext(coid, url)
        return self._ccc[coid]

    def purge_results(self):
        # FIXME need to specify API and implement;
        # this method should drop results that were returned
        # more than N seconds ago, and drop stale results,
        # i.e. never sent to a client but generated more than
        # M seconds ago. These should be configuable.
        # Add fields to Result to make this happen.
        pass

    def message_from(self, msg, ccc):
        """
        Handle a (parsed) message from a given component.

        """
        token = msg.get_token()
        label = msg.get_label()

        logger.debug("got message "+repr(msg))

        if isinstance(msg, mplane.model.Envelope):
            for emsg in msg.messages():
                self.message_from(emsg, ccc)
                return
        elif isinstance(msg, mplane.model.Exception):
            logger.error("exception from "+repr(ccc)+": "+repr(msg))
            return
        elif isinstance(msg, mplane.model.Capability):
            # store and/or update
            ccc.capabilities[token] = msg
            if label:
                ccc.token_for_label[label] = token

            # rewrite link
            if not msg.get_link() and ccc.url:
                msg.set_link(ccc.url)

            # signal we have caps
            self._i_have_capabilities.set()

        elif isinstance(msg, mplane.model.Withdrawal):
            try:
                del(ccc.capabilities[token])
                del(ccc.token_for_label[label])
            except KeyError:
                pass
        elif isinstance(msg, mplane.model.Receipt):
            ccc.receipts[token] = msg
            if label:
                ccc.token_for_label[label] = token
            # we have a receipt.
            self._token_invoked[token].set()
        elif isinstance(msg, mplane.model.Result):
            ccc.results[token] = msg
            if label:
                ccc.token_for_label[label] = token
            try:
                del(ccc.receipts[token])
            except KeyError:
                pass
            self._token_complete[token].set()
        else:
            reply = mplane.model.Exception(token=token, errmsg="bad message type for client")
            logger.warning("client cannot handle message "+repr(msg))

    def _search_tol(self, access_name, access_lambda, token_or_label, coid=None):
        if coid:
            cccs = [self._component_context(coid)]
        else:
            cccs = [self._ccc[k] for k in self._ccc]

        for ccc in cccs:
            if token_or_label in ccc.token_for_label:
                token = ccc.token_for_label[token_or_label]
            else:
                token = token_or_label
            if token in access_lambda(ccc):
                return (ccc, access_lambda(ccc)[token])

        raise KeyError("no "+str(access_name)+" for token or label "+token_or_label)        

    def capability_for(self, token_or_label, coid=None):
        """
        Retrieve the first matching capability given a token or label.
        If a component identity is given, search for matching capabilities 
        from that component only; otherwise search all known capabilities.

        """
        return self._search_tol("capability", lambda x: x.capabilities, token_or_label, coid)

    def receipt_for(self, token_or_label, coid=None):
        """
        Retrieve the first matching receipt given a token or label.
        If a component identity is given, search for matching receipts 
        from that component only; otherwise search all available receipts.

        """
        return self._search_tol("receipt", lambda x: x.receipts, token_or_label, coid)

    def result_for(self, token_or_label, coid=None):
        """
        Retrieve the first matching result given a token or label.
        If a component identity is given, search for matching results 
        from that component only; otherwise search all available results.

        """
        return self._search_tol("result", lambda x: x.results, token_or_label, coid)

    def _specification_for(self, cap_tol, when, params, relabel=None, coid=None):
        """
        Given a capability token or label, a temporal scope, a dictionary
        of parameters, and an optional new label, derive a specification
        ready for invocation, and return the capability and specification.

        Used internally by derived classes; use invoke_capability instead.

        """
        (ccc, cap) = self.capability_for(cap_tol, coid)
        spec = mplane.model.Specification(capability=cap)

        # set temporal scope
        spec.set_when(when)

        # fill in parameters
        # spec.set_single_values() # this is automatic now
        for pname in spec.parameter_names():
            if spec.get_parameter_value(pname) is None:
                if pname in params:
                    spec.set_parameter_value(pname, params[pname])
                else:
                    raise KeyError("missing parameter "+pname)

        # regenerate token based on parameters and temporal scope
        spec.retoken()

        # generate label
        if relabel:
            spec.set_label(relabel)
        else:
            spec.set_label(cap.get_label() + "-" + str(self.next_label_serial))
        self.next_label_serial += 1

        return (ccc, cap, spec)

    async def await_capabilities(self):
        logger.debug("waiting for capabilities...")
        await self._i_have_capabilities.wait()

    def invoke_capability(self, cap_tol, when, params, 
                          relabel=None, coid=None):
        """
        Invoke a capability given a token or label, a temporal scope, 
        and a dictionary mapping parameter names to values. 
        If a component identity is given, search for matching capabilities 
        from that component only; otherwise search all known capabilities.

        Creates a specification and schedules it to be sent to the
        appropriate component. Returns the specification.
        """

        # get a spec and put it in the right outgoing queue
        (ccc, cap, spec) = self._specification_for(cap_tol, when, params, relabel, coid)
        spec.validate()
        ccc.send(spec)

        # create semaphores
        token = spec.get_token()
        self._token_invoked[token] = asyncio.Event()
        self._token_complete[token] = asyncio.Event()
        return spec        

    async def await_invocation(self, cap_tol, when, params, 
                               relabel=None, coid=None):
        # invoke the capability
        spec = self.invoke_capability(  cap_tol = cap_tol, 
                                        when = when,
                                        params = params,
                                        relabel = relabel,
                                        coid = coid)
        token = spec.get_token()

        # wait for invocation to complete
        await self._token_invoked[token].wait()

        # return the spec
        return spec

    def interrupt(self, spec_tol, coid=None):
        """
        Send an interrupt given a specification token or label.

        """
        (ccc, receipt) = self.receipt_for(spec_tol, coid)
        ccc.send(mplane.model.Interrupt(specrec=receipt))
        pass

    def retrieve_result(self, spec_tol, coid=None):
        """
        Retrieve a cached result, or resend a redemption if not yet available.
        Returns the result if available or the receipt if not.
        """
        # First try to get the cached result
        try:
            (ccc, result) = self.result_for(spec_tol, coid)
            return result
        except KeyError:
            pass

        # Then try to get a receipt, and send a redemption
        (ccc, receipt) = self.receipt_for(spec_tol, coid)
        ccc.send(mplane.model.Redemption(receipt=receipt))
        return receipt

    async def await_result(self, token, timeout=None):
        """
        Wait for a result to return from an invoked specification

        """
        eventwait = self._token_complete[token].wait()

        done, pending = await asyncio.wait((eventwait,), timeout=timeout)

        if eventwait in done:
            return self.retrieve_result(token)
        else:
            return None

class WSClientClient(CommonClient):
    """
    A Client which acts as a WebSockets client
    (for client-initiated connection establishment). 
    """
    def __init__(self, config):
        super().__init__(config)

        # Shutdown event
        self._sde = asyncio.Event()

        # Task for connect()
        self._task = None

        # Configuration
        self.url = config["Client"]["WSInitiator"]["url"]
        self.tls = mplane.tls.TlsState(config)

    async def connect(self):
        # connect to the component
        async with websockets.connect(self.url) as websocket:
            logger.debug("connection to "+self.url+" opened") 

            # get my component context
            # FIXME use URL for now
            ccc = self._component_context(self.url, self.url) 

            try:
                # now exchange messages until the shutdown flag is true
                while not self._sde.is_set():

                    rx = asyncio.ensure_future(websocket.recv())
                    tx = asyncio.ensure_future(ccc.outq.get())
                    sd = asyncio.ensure_future(self._sde.wait())
                    done, pending = await asyncio.wait((rx, tx, sd), 
                                        return_when=asyncio.FIRST_COMPLETED)

                    if rx in done:
                        self.message_from(mplane.model.parse_json(rx.result()), ccc)
                    else:
                        rx.cancel()

                    if tx in done:
                        await websocket.send(mplane.model.unparse_json(tx.result()))
                    else:
                        tx.cancel()

                    if sd in done:
                        break
                    else:
                        sd.cancel()

            except websockets.exceptions.ConnectionClosed:
                # FIXME schedule a reconnection attempt
                logger.debug("connection to "+ccc.coid+" closed") 
            finally:
                logger.debug("shutting down")

    # async def poll_for_result(self, token, poll=1):
    #     while True:
    #         res = self.retrieve_result(token)
    #         if isinstance(res, mplane.model.Result):
    #             return res
    #         await asyncio.sleep(poll)

    def start_running(self):
        self._task = asyncio.ensure_future(self.connect())
        logger.debug("client started task "+repr(self._task))

    def stop_running(self):
        logger.debug("signaling shutdown")
        self._sde.set()
        asyncio.get_event_loop().run_until_complete(self._task)

def websocket_coid(websocket, path=None):
    """
    Get a component ID from the websocket's peer certificate (for wss:// URLs),
    allow the component to provide a component ID on the websocket path 
    (for ws:// URLs), or default to a UUID for anonymous components

    """ 

    # Extract CID from subject common name 
    # (see https://docs.python.org/3/library/ssl.html#ssl.SSLSocket.getpeercert)
    # Problem: WebSocketServerProtocol doesn't implement get_extra_info :(
    # Possible solution: look at the source and use private fields :(
    #
    # peercert = websocket.get_extra_info("peercert", default=None)
    # if peercert:
    #     for rdn in peercert['subject']:
    #         if rdn[0][0] == "commonName":
    #             return rdn[0][1]

    # No peer cert. Extract CID from path
    if path and path != "/":
        return path

    # No peer cert and no path. Generate a UUID for an anonymous client
    return str(uuid.uuid4())


class WSServerClient(CommonClient):
    """
    A Client which acts as a WebSockets server
    (for component-initiated connection establishment). 
    """ 
    def __init__(self, config):
        super().__init__(config)

        # Shutdown event
        self._sde = asyncio.Event()

        # Connection information
        interface = config["Client"]["WSListener"]["interface"]
        port = int(config["Client"]["WSListener"]["port"])
        tls = mplane.tls.TlsState(config)
        
        # Coroutine to bring the server up
        self._start_server = websockets.server.serve(self.serve, interface, port, ssl=tls.get_ssl_context())

    async def serve(self, websocket, path):
        # get my component context
        ccc = self._component_context(websocket_coid(websocket, path))
        logger.debug("client got connection from "+ccc.coid)

        # now exchange messages forever
        try: 
            while not self._sde.is_set():
                rx = asyncio.ensure_future(websocket.recv())
                tx = asyncio.ensure_future(ccc.outq.get())
                sd = asyncio.ensure_future(self._sde.wait())
                done, pending = await asyncio.wait((rx, tx, sd), 
                                    return_when=asyncio.FIRST_COMPLETED)

                if rx in done:
                    self.message_from(mplane.model.parse_json(rx.result()), ccc)
                else:
                    rx.cancel()

                if tx in done:
                    await websocket.send(mplane.model.unparse_json(tx.result()))
                else:
                    tx.cancel()

                if sd in done:            
                    logger.debug("break on _sde")
                    break
                else:
                    sd.cancel()
        except websockets.exceptions.ConnectionClosed:
            logger.debug("connection from "+ccc.coid+" closed")
        finally:
            logger.debug("shutting down")

    def start_running(self):
        self.wssvr = asyncio.get_event_loop().run_until_complete(self._start_server)
        logger.debug("client created wssvr "+repr(self.wssvr))

    def stop_running(self):
        self._sde.set()
        self.wssvr.close()
        asyncio.get_event_loop().run_until_complete(self.wssvr.wait_closed())


